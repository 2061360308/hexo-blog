{"meta":{"title":"盧瞳Blog","subtitle":"","description":"","author":"盧瞳","url":"http://blog.1think2program.cn","root":"/"},"pages":[{"title":"关于我","date":"2022-12-30T03:29:23.719Z","updated":"2022-12-30T03:29:23.719Z","comments":true,"path":"system/about.html","permalink":"http://blog.1think2program.cn/system/about.html","excerpt":"","text":"关于我你有什么想知道的吗？"},{"title":"文章归档","date":"2022-12-27T08:47:26.661Z","updated":"2022-12-27T08:47:26.661Z","comments":true,"path":"system/archive.html","permalink":"http://blog.1think2program.cn/system/archive.html","excerpt":"","text":""},{"title":"友人帐","date":"2013-07-13T12:46:25.000Z","updated":"2022-12-30T01:54:17.146Z","comments":true,"path":"system/friends.html","permalink":"http://blog.1think2program.cn/system/friends.html","excerpt":"","text":"午后的 松柏树下 随风摇晃的 枝丫落叶 送别了盛夏 温度也 急转直下漫步在 肩并肩 走过的路 回忆 应接不暇也 会有 遗憾吧 比如 我失去了他在纸上 涂涂画画 心事 不经意的 写下仍会 莫名的牵挂 写下的 名字 是他曾经的 情投意洽 如今早已 各自天涯是否 要留下遗憾 才让人 念念不忘是否 要与你无关 内心才 毫无波澜从前的 侃侃而谈 人后的 惴惴不安在 喧嚣之外 孤单 戒掉 廉价的 浪漫为何 留下了遗憾 留下了 长吁短叹似 从未走出一般 来来回回 兜兜又转转与其 强求的圆满 不如 坦然的 离散等待着 大雾尽散 清风白云 与我相伴 友情链接 申请友链1234名称: 盧瞳Blog地址: https://blog.1think2program.cn头像: https://blog.1think2program.cn/images/head.jpg描述: 先思考后编程"},{"title":"留言板","date":"2022-12-27T16:45:37.000Z","updated":"2022-12-27T19:31:16.118Z","comments":true,"path":"system/message.html","permalink":"http://blog.1think2program.cn/system/message.html","excerpt":"","text":"恭喜你来到了这个博客最最最精华的版面，有什么想说的在请这里留言哦！"}],"posts":[{"title":"Flask 学习汇总","slug":"技术/Flask学习记录","date":"2023-01-02T08:09:25.000Z","updated":"2023-01-23T15:59:22.269Z","comments":true,"path":"2023/01/02/技术/Flask学习记录/","link":"","permalink":"http://blog.1think2program.cn/2023/01/02/%E6%8A%80%E6%9C%AF/Flask%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"写在前面本篇文章涵盖了Python Flask从基础开发环境搭建到应用上云的全过程，囊括了Flask基础，进价知识，jinjia2模板语法，此外还插入了Pipenv环境使用，Falsk前后端视图分离，以及笔者学习过程中使用到的Flask-SQLAlchemy和flask_login这俩个flask扩展库等等的内容，涵盖齐全，但由于篇幅所限适合回顾或是了解flask大致走向所用。(Flask-SQLAlchemy部分没写，实在是太多了，可以看到文章的创建日期是1月2日事实上我实在1月23日发布的文章，由此可见……) 文章前半部分是笔者看过《FlaskWeb开发实战：入门、进阶与原理解析》_李辉这本书后回顾时边看边挑选摘出的内容，后半部分是笔者查看这段时间学习时的练习项目中的关键代码结合所学知识整理而出。在此强烈向大家推荐这本书，并向李辉作者致谢！ [Toc] 环境准备Python Pipenv Pipenv说实话博主在开始学习Flask之前一直使用Pycharm和pip，像管理虚拟环境这些都是Pycharm来管理的，已经有把我养废的趋势。这次准备自己手动尝试管理，这里就在介绍Flask之前先介绍一下Pipenv Pipenv介绍首先要了解Pipenv是什么呢？简单来说它是pip的升级版，在默认使用pip时我们的工作方式一般是pip + virtualenv + requirements.txt，Pipenv能帮我们解决默认方式的弊端,具体来说：Pipenv呢它是pip，PIPfile和virtualenv的结合体可以帮我们更加方便地管理包和包依赖以及虚拟环境的安装，使用它能够使我们实现高效的Python项目开发流。 安装 使用pip install pipenv直装就好 创建虚拟环境 进入项目的根目录 执行pip install命令 注意：1. 在默认情况下，pipenv会统一管理所有的虚拟环境。在Windows系统中，虚拟环境文件夹会在C:\\Users\\用户名.virtualenvs\\目录下创建，而在Linux或MASOS系统中会在~&#x2F;.local&#x2F;share&#x2F;virtualenvs&#x2F;目录下创建。虚拟环境文件夹的目录名称形式为“当前项目目录名+一串随机字符，比如helloflask-5Pa0ZfZw”我们可以通过设置环境变量PIPENV_VENV_IN_PROJECT这时名为.venv的虚拟环境将在项目根目录被创建。2. 你可以通过--three和two选项来声明虚拟环境中使用的Python版本（分别对应Python3和Python2），或是使用--python选项指定具体的版本号。同时要哦确保对应版本的Python已经安装在电脑中。3. 使用pipenv shell命令显式地激活虚拟环境。当你执行pipenv shell或是pipenv run命令时，Pipenv会从项目目录下的.env文件中加载环境变量，而且当你使用Linux系统时激活成功后命令行提示符前会添加虚拟环境的名称4. 除了使用上述的pipenv shell命令外，Pipenv还提供了一个pipenv run命令，这个命令允许你不显示激活虚拟环境即可在当前项目的虚拟环境中执行命令，比如pipenv run python hello.py这会使用虚拟环境中的Python解析器。事实上，这种方式是更推荐的做法，因为它可以让你在执行操作时不用关心自己是否激活了虚拟环境，当然最终还是按你偏爱的用法操作了。 管理依赖在创建虚拟环境时，如果项目根目录下没有Pipfile文件，Pipenv install命令还会在项目文件夹根目录下创建Pipfile和Pipfile.lock文件，前者用于记录项目依赖包列表，而后者记录了固定版本的详细依赖安装包列表。当我们使用Pipenv安装删除更新依赖包时，Pipfile以及Pipfile.lock会自动更新，这比pip使用reqirements.txt，需要我们手动更新方便多了。 安装Flaskpipenv install flaskPipenv会帮我们自动管理虚拟环境，无论你是否激活虚拟环境这条命令都会将flask装入虚拟环境中 安装python-dotenv管理环境变量pipenv install python-dotenv具体环境变量管理知识详见下文 安装watchdog获取更好的调试体验默认会使用Werkzeng内置的stat重载器，他的缺点是耗电严重且准确性一般，为了获取更优秀的体验，我们需要安装Watchdog来监测文件变动，安装后自动生效。pipenv install watchdog --dev因为这个包只在开发时会用到，所以我们在安装命令后添加了一个–dev选项，这用来把这个包声明为开发依赖。在Pipfile文件中，这个包会被添加到dev-packages部分。 Flask基础 这部分记录flask使用基础 flask基本模式示例12345678910from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;&lt;h1&gt;hello,World!&lt;/h1&gt;&#x27;​```python&gt;传入Flask构造方法的第一个参数是模块或包的名称，我们使用特殊变量__name__&gt;### 一个视图绑定多个URL @app.rout(‘&#x2F;hi’)@app.rout(‘&#x2F;hello’)def say_hello(): …… 123456### 动态路由在路由定义中使用`&lt;变量名&gt;`,Flask在处理请求时会把变量传入视图函数，我们可以添加参数来获取这个变量值​```python@app.route(&#x27;/greet/&lt;name&gt;&#x27;)def greet(name): return ...... 启动开发服务器使用命令flask run可以启动内置的开发服务器，也可以使用app.run()方法 自动发现程序的规则使用上述命令后： flask会从当前目录寻找app.py和wsgi.py模块，并从中寻找名为app或application的程序 从环境变量FLASK_APP对应值寻找名为app或者application的程序实例在没有设置FLASK_APP时你需要将程序的主模块命名为app.py或者你使用环境变量指定需要搜寻的其他名称 管理环境变量如果你安装了python-dotenv，那么使用flask run或者其他命令时他会自动从.flaskenv文件和.env文件中加载环境变量，具体的优先级是：手动设置的环境变量&gt;.env中设置的环境变量&gt;.flaskenv中设置的环境变量 鉴于手动设置环境变量太繁琐且不便于管理，而且开发多个flask程序时需要频繁切换，最好安装python-dotenv使用.env和.flaskenv管理环境变量，其中前者用来存储包含敏感信息的环境变量，如账户，密码，秘钥之类。 .env和.flaskenv具体书写格式为:键值对形式，每行一个，’#’标注注释，如 123456789101112#秘钥SECRET_KEY=089de6ba-7874-11ed-8134-e4fd453f23ec# FLASK_ENV 变量代表运行时的环境时开发环境(development)还是生产环境(production)FLASK_DEBUG=1# FLASK_DEBUG 变量代表是否开启调试器开启1关闭0,开发模式下默认开启,不建议手动操作此项目# FLASK_DEBUG=1# FLASK_APP 变量代表执行flask run命令时要运行的应用文件FLASK_APP=run.py# FLASK_RUN_HOST 变量代表运行的host 0.0.0.0代表外部计算机访问/127.0.0.1代表本机访问FLASK_RUN_HOST=0.0.0.0# FLASK_RUN_PORT 变量代表监听的端口默认5000FLASK_RUN_PORT=5000 注意不要把.env上传到GIt仓库中哦。 启动选项-扩展语法 使用--host=0.0.0.0指定Web服务器对外可见1flask run --host=0.0.0.0 使用--port=端口值改变5000的默认端口1flask run --port=80 Flask Shell开发Flask程序时我们并不会直接使用python命令启动的Python Shell而是使用flask shell命令：在终端中执行flask shell命令启动flask shell Flask扩展flask只提供基础的功能，我们需要各种其他的扩展，因为Flask扩展编写有一些约定，他们一般命名为flask_扩展名，且一般来说扩展会提供一个扩展类，实例化这个类，并传入我们创建的程序实例app作为参数，即可完成初始化过程 项目配置配置变量实际上就是一些大写形式的Python变量，可以避免在程序中以硬编码的形式设置程序 注意：配置的名称必须全是大写形式，小写的变量将不会被读取 这些变量通过Flask对象的app.congig属性作为统一的接口,有多种方式操作他们存: app.config[&quot;NAME&quot;] &#x3D; ‘Peter’ app.congig.update&#123;NAME = True,SECRET_KEY=&#39;dsfasf@3dfa&#39;&#125; 将配置变量保存到单独的Python脚本，JSON格式的文件或者Python类中，config对象提供了相应的方法来导入配置，具体有：取:取出的方式与操作字典类似 value = app.config[&#39;NAME&#39;] url_for()函数使用url_for()函数可以避免使用硬编码的方式书写路由（URL）规则 1 如果要获取绝对路径需要设置_external参数设为True 自定义Flask命令通过特殊装饰器app.cli.command()装饰器 123@app.cli.command()def hello(): click.echo(&#x27;Hello,World!&#x27;) 上述注册的命令即hello，可以使用flask hello命令触发函数。作为提单，你也可以在app.cli.command()装饰器中传入参数来设置命令名称 123@app.cli.command(&#x27;say-hello&#x27;)def hello(): click.echo(&#x27;Hello,World!&#x27;) 模板与静态文件默认情况下flask会读取根目录中的templates文件夹作为HTML模板文件夹，而今天资源则会在根目录下static文件夹中获取HTML中引用static文件夹中静态资源时需要使用url_for()函数url_for(&#39;admin_view.static&#39;, filename=&#39;css/add.css&#39;) Flask进阶Reques对象我们首先使用导入from flask import Flask requeat 使用Request的属性获取请求的URL假设请求的URL是http://helloftask.com/hello?name=Grey 当Flask接收到请求后，请求对象会提供多个属性来获取URL的各部分，以下是常用属性表： 属性 值 path u’&#x2F;hello’ full_path u’hello?name&#x3D;Grey’ host u’helloftask.com’ host_url u’http://helloftask.com/‘ base_url u’http://helloftask.com/hello‘ url u’http://helloftask.com/hello?name=Grey‘ url_root http://helloftask.com/ Request对象常用的属性和方法 属性&#x2F;方法 说明 arg 解析后的查询字符串，可通过字典方式获取键值，如果想要获取未解析的原生字符串，可以使用query_string属性 blueprint 当前蓝本的名称 cookies 随请求提交的cookies字典 data 字符串形式的请求数据 endpoint 与当前请求匹配的端点值 files 所有上传文件，可以使用字典的形式获取文件。使用的键为文件input标签中的name属性值作为键获取 form 包含解析后的表单数据，通过input的name属性值作为键获取 values 结合了args和form属性的值 get_data(cache&#x3D;True,as_text&#x3D;False,parse_from_data&#x3D;False) 获取请求中的数据，默认读取为字节串，将as_text设置为True则返回值将是解码后的unicode字符串 get_json(self,force&#x3D;False,silent&#x3D;False,cache&#x3D;True) 作为Json解析并返回数据，如果MIME类型不是JSON，则返回None(除非force设为True)；解析出错则抛出BadRequest异常（如果为开启调试模式，则返回400错误响应），如果silent设为True则返回None；cache设置是否缓存解析后的JSON数据 headers 首部字段，以字典形式操作 is_json 通过MIME类型判断是否为JSON数据，返回布尔值 json 包含解析后的JSON数据，内部调用get_json(),通过字典方式获取键值 method 请求的HTTP方法 referrer 请求发起的源，即referer scheme 请求的URL模式（http或https） user_agent 用户代理，包含了用户的客户端类型，操作系统类型等信息 其中最长使用的是arg（获取get方法请求传入的数据）form（获取post请求传入的数据）values（同时获取get和post请求获取的数据）get_json(获取JSON格式的数据) 处理请求设置监听的HTTP方法12@app.route(&#x27;/hello&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def ...... URL处理在URL中使用变量直接传入会造成安全隐患，我们应该对奇根据我们需要进行转义后再继续使用，Flask提供一些转换器帮我们简化了这个任务例如你可以使用变量int:year,Flask在解析这个URL变量时会将其转换为整型数据传入 Flask内置的URL变量转换器 转换器 说明 string 不包含斜线的字符串（默认值） int 整型 float 浮点数 path 包含斜线的字符串，static路由规则中的filename变量就使用了这个转换器 any 匹配一系列给定值中的一个元素，具体使用方法为&lt;any(value1,value2,……):变量名&gt; uuid UUID字符串 请求钩子对请求进行预处理和后处理 1234# 预处理例子@app.before_requestdef do_something(): pass # 这里的代码会在每个请求处理前执行 注意，这些请求都能注册任意多个处理函数，函数名并不要求必须和钩子名称相同，下面是请求钩子的列表 钩子 说明 before_first_request 处理第一个请求之前执行 before_request 处理每个请求前都要执行 after_request 如果没有未处理的异常抛出，会在每个请求结束后运行 treardown_request 即使有未处理异常抛出，也会在每个请求结束后执行，如果发生异常，会传入异常对象作为参数到注册的函数中 after_this_request 在视图内注册一个函数，会在这个请求结束后运行 生成响应Flask的视图函数必须有返回，否则报错！视图函数可以返回最多由三个元素组成的元组：响应主体、状态码、首部字段其中普通的请求只需要响应主体就行：return &#39;hello world&#39;指定状态码：return &#39;hello world,201&#39;修改或附加某个首部字段：重定向目标URLreturn &#39;&#39;,302,&#123;&#39;Location&#39;:&#39;http:www.exmple.com&#39;&#125; 重定向使用函数redirect(url) 1234@app.route(...)def hello(): ... return redirect(&#x27;http:...&#x27;) 其中默认状态码为302，即临时重定向，可以通过在函数中传入第二个参数或者使用code关键字传入替代默认值如果需要在程序内重定向到其他视图，只需在redirect中使用url_for()生成目标URL就行 1234@app.route(...)def hello(): ... return redirect(url_for(&#x27;hi&#x27;)) # 重定向到/hi 错误响应Flask会自动处理常见的错误响应，可以通过Flask提供的abort()函数抛出异常，about()前不需要return，且about()后的代码不会被执行 123@app.route(&#x27;/404&#x27;)def not_found(): about(404) jsonify()函数jsonify包装了json模块的内容，且会自动生成响应对象且设置正确的MIME类型，你可以传入普通参数，也可以传入关键字参数，还可以像使用dumps()一样传入更加直观的字典或元组 12345678910from flask import jsonify@app.rout(&#x27;/foo&#x27;)def foo(): return jsonify(&#123;&#x27;name&#x27;:&quot;Grey Li&quot;&#125;) # 或者使用 return jsonify(name=&#x27;Grey&#x27;) # 或者使用 return jsonify(&quot;&#123;&#x27;name&#x27;:&#x27;Grey Li&#x27;&#125;&quot;) # 你还可以附加状态码来自定义响应类型 return jsonify(&#123;&#x27;name&#x27;:&quot;Grey Li&quot;&#125;),500 使用Cookie设置cookie发送cookie需要用到Response类提供的set_cookie()方法，下面简单罗列一下此方法所支持的常用参数 属性 说明 key cookie创建的键名称 value cookie的值 max_age cookie被保存的时间数，单位秒，默认在用户会话结束（关闭浏览器）时过期 expires 具体的过期时间，一个datetime对象或UNIX时间戳 path 限制cookie只给指定的路径可用，默认为整个域名 domain 设置cookie可用的域名 secure 如果为True，只有通过Https才可以使用 httponly 若果设为True那么禁止客户端javaScript获取cookie 12345678910from flask import Falsk,make_response@app.rout(&#x27;/set/&lt;name&gt;&#x27;)def set_cookie(name): response = make_response(redirect(url_for(&#x27;hello&#x27;))) response.set_cookie(&#x27;name&#x27;,name) return response # 上面这段示例代码可以看做是简单登录功能的一部分实现用户登录过后跳转到set_cookie为其设置cookie记录登录转态，然后跳转到正式界面，事实上上面代码漏洞很大，此处仅仅是作为设置cookie的实例 当浏览器保存了服务端设置的cookie后，浏览器再次发送到该服务器的请求会自动携带设置的cookie信息 读取cookie设置好cookie后我们就可以在需要的时候读取cookie了，正如上文所诉，cookie是和请求一起发送的，因此我们可以使用flask的request对象获取cookie使用request.cookie.get(p_srt)方法 1234from flask import Falsk,request@app.rout(&#x27;/hello&#x27;)def hello(): name = request.cookies.get(&#x27;name&#x27;) session：更加安全的cookie有经验的小伙伴一定知道我们在浏览器中可以查看和修改存储的cookie,有些时候比如我们使用cookie存储用户的登录状态的时候，我们不想让其他人查看和修改，以防恶意用户伪造cookie他人账户，这时我们就需要对敏感的cookie内容进行加密，方便的是flask提供了session对象来将cookie进行加密储存，默认情况下他把数据储存在浏览器上一个名为session的cookie中 要想使用session你需要先为flask设置秘钥,你可以使用Flask.secret_key属性或配置环境变量SECRET_KET具体做法是app.secret_key=&#39;secret string&#39;这样做固然可以，但更加安全的做法是将其写入系统环境变量，考虑到不同项目间的干扰我们最好是写入上文所提到的.env文件中你应该在.env这么写SECRET_KEY=secret string然后在脚本程序中使用os提供的getenv获取： 12345678import os# ......app.secret_key=os.getenv(&#x27;SECRET_KEY&#x27;,&#x27;secret string&#x27;) # 第二个参数是在环境变量中没有获取到情况时使用的默认值，（此处应该报警^-^） 有了秘钥接下是写入session 的正式环节了 12345678from falsk import session@app.route(&#x27;/login&#x27;)def login(): session[&#x27;logged_in&#x27;] = True # 写入session ......# session中的数据可以像字典一样读取或是使用get方法，区别是前者没有报错后者返回None Falsk上下文JinJia2上面我们已经简单说过了flask的模板与静态文件，而flask中渲染网页使用的jinjia2这个库，下面我们来具体说说它的语法,这部分网上有很多讲解，笔者直接粘贴了，打字好累 来源版权 | 版权声明： 以下jinjia2用法来自博客园博主「浩浩学习」的原创文章，原文链接：https://www.cnblogs.com/hhaostudy/p/16119959.html 变量jinja2模板中使用 {{ }} 语法表示一个变量，它是一种特殊的占位符。当利用jinja2进行渲染的时候，它会把这些特殊的占位符进行填充&#x2F;替换，jinja2支持python中所有的Python数据类型比如列表、字段、对象等。 使用{{变量名}}包裹的是一个变量下面是一个简单的实例： 123456789101112# /templates/index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;你好&#123;% raw %&#125;&#123;&#123;name&#125;&#125;&#123;% endraw %&#125;&lt;/body&gt;&lt;/html&gt; 在Python中我们这样使用 12345678# ./app.py......return render_template(&quot;index.html&quot;, name=&quot;世界&quot; ) 其他支持的数据类型 123&lt;p&gt;this is a dicectory:&#123;% raw %&#125;&#123;&#123; mydict[&#x27;key&#x27;] &#125;&#125;&#123;% endraw %&#125; &lt;/p&gt;&lt;p&gt;this is a list:&#123;% raw %&#125;&#123;&#123; mylist[3] &#125;&#125;&#123;% endraw %&#125; &lt;/p&gt;&lt;p&gt;this is a object:&#123;% raw %&#125;&#123;&#123; myobject.something() &#125;&#125;&#123;% endraw %&#125; &lt;/p&gt; 过滤器 jinja2中的过滤器 过滤器名称 说明 safe 渲染时值不转义 capitialize 把值的首字母转换成大写，其他子母转换为小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格去掉 striptags 渲染之前把值中所有的HTML标签都删掉 join 拼接多个值为字符串 replace 替换字符串的值 round 默认对数字进行四舍五入，也可以用参数进行控制 int 把值转换成整型 循环迭代列表12345&lt;ul&gt;&#123;% for user in users %&#125;&lt;li&gt;&#123;% raw %&#125;&#123;&#123; user.username|title &#125;&#125;&#123;% endraw %&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 迭代字典123456&lt;dl&gt;&#123;% for key, value in my_dict.iteritems() %&#125;&lt;dt&gt;&#123;% raw %&#125;&#123;&#123; key &#125;&#125;&#123;% endraw %&#125;&lt;/dt&gt;&lt;dd&gt;&#123;% raw %&#125;&#123;&#123; value&#125;&#125;&#123;% endraw %&#125;&lt;/dd&gt;&#123;% endfor %&#125;&lt;/dl&gt; 当然也可以加入else语句，在循环正确执行完毕后，执行 判断 if语句使用if条件判断语句必须放在。和python中的类似， 可以使用&gt;，&lt;，&lt;&#x3D;，&gt;&#x3D;，&#x3D;&#x3D;，!&#x3D;来进行判断，也可以通过and，or，not，()来进行逻辑合并操作 1234567&#123;% if name==1 %&#125; &lt;!--name的值是否等于1--&gt;&lt;h1&gt;恭喜，您抽中了一等奖！&lt;/h1&gt; &lt;!--name的值等于1，显示本行h1代码--&gt;&#123;% elif name==2 %&#125; &lt;!--name的值是否等于2--&gt;&lt;h1&gt;恭喜，您抽中了二等奖！&lt;/h1&gt;&#123;% else %&#125; &lt;!--name的值是否等于其他--&gt;&lt;h1&gt;恭喜，您抽中了三等奖！&lt;/h1&gt;&#123;% endif %&#125; &lt;!--结束if语句--&gt; 在for循环中，jinja2还提供了一些特殊的变量，用以来获取当前的遍历状态： 变量 描述 loop.index 当前迭代的索引（从1开始） loop.index0 当前迭代的索引（从0开始） loop.first 是否是第一次迭代，返回bool loop.last 是否是最后一次迭代，返回bool loop.length 序列中的项目数量 loop.revindex 到循环结束的次数（从1开始） loop.revindex0 到循环结束的次数(从0开始） jinja2的宏宏类似于Python中的函数，我们在宏中定义行为，还可以进行传递参数，就像Python中的函数一样一样儿的。 在宏中定义一个宏的关键字是macro，后面跟其 宏的名称和参数等 123456789&#123;% macro input(name,age=18) %&#125; # 参数age的默认值为18 &lt;input type=&#x27;text&#x27; name=&quot;&#123;% raw %&#125;&#123;&#123; name &#125;&#125;&#123;% endraw %&#125;&quot; value=&quot;&#123;% raw %&#125;&#123;&#123; age &#125;&#125;&#123;% endraw %&#125;&quot; &gt; &#123;% endmacro %&#125;调用方法也和Python的类似&lt;p&gt;&#123;% raw %&#125;&#123;&#123; input(&#x27;daxin&#x27;) &#125;&#125;&#123;% endraw %&#125; &lt;/p&gt;&lt;p&gt;&#123;% raw %&#125;&#123;&#123; input(&#x27;daxin&#x27;,age=20) &#125;&#125;&#123;% endraw %&#125; &lt;/p&gt; jinja2的继承和Super函数jinja2中最强大的部分就是模板继承。模板继承允许我们创建一个基本(骨架)文件，其他文件从该骨架文件继承，然后针对自己需要的地方进行修改。 jinja2的骨架文件中，利用block关键字表示其包涵的内容可以进行修改。 以下面的骨架文件base.html为例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &#123;% block head %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;/&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Webpage&lt;/title&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;content&quot;&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &#123;% block footer %&#125; &lt;script&gt;This is javascript code &lt;/script&gt; &#123;% endblock %&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里定义了四处 block，即：head，title，content，footer。那怎么进行继承和变量替换呢？注意看下面的文件 12345678910&#123;% extend &quot;base.html&quot; %&#125; # 继承base.html文件 &#123;% block title %&#125; Dachenzi &#123;% endblock %&#125; # 定制title部分的内容 &#123;% block head %&#125; &#123;% raw %&#125;&#123;&#123; super() &#125;&#125;&#123;% endraw %&#125; # 用于获取原有的信息 &lt;style type=&#x27;text/css&#x27;&gt; .important &#123; color: #FFFFFF &#125; &lt;/style&gt;&#123;% endblock %&#125; 其他不修改的原封不同的继承PS: super()函数 表示获取block块中定义的原来的内容。 Flask 蓝图要正式开发一个web项目把所有的路由关系都塞到一个app.py中是显然行不通的，最起码这是不是一个很好的办法，这时候就需要falsk为我们提供的蓝图 使用蓝图大致可以分为三个步骤 创建一个蓝图对象 在这个蓝图对象上进行操作,注册路由,指定静态文件夹 …… 在应用对象上注册这个蓝图对象 下面三段代码分别代表上述三个过程 123456789admin_view = Blueprint(name=&#x27;admin_view&#x27;, import_name=__name__, static_folder=&quot;../models/admin/static&quot;, static_url_path=&quot;/admin_static&quot;, template_folder=&#x27;../models/admin/templates&#x27;, url_prefix=&quot;/admin&quot;, )# 参数分别为“蓝图名称”,&quot;静态文件夹目录&quot;,&quot;静态文件夹需要映射到的路由&quot;,&quot;模板文件文件夹&quot;，“为蓝图中所有路由前添加的前缀” 使用蓝图 @admin_view.route(&#39;/&#39;) 12345678910111213141516171819# 根目录@admin_view.route(&#x27;/&#x27;)def root(): # put application&#x27;s code here data = dbModel.User.query.filter_by(id=1).first() name = data.name head_portrait_id = data.head_portrait head_portrait = dbModel.Pic.query.filter_by(id=head_portrait_id).first().data head_portrait = base64.b64encode(head_portrait).decode(&quot;utf-8&quot;) rootPath = current_app.config.get(&#x27;ROOT_PATH&#x27;) data_templates = render_template(&quot;admin_data.html&quot;, rootPath=rootPath, left_page_name_List=left_page_name_List) return render_template(&quot;admin_base.html&quot;, head_portrait=head_portrait, name=name, rootPath=rootPath, data_templates=data_templates, ) 大型项目构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Flask项目文件分配示意图项目根目录||——+app(项目文件夹)| || |+——api（所有api存放文件夹）| || |+——application| | || | |——app.py(这里真正创建app对象，其他文件从这里调用app)| | || | |——extensions.py(导入扩展并初始化)| | || | |——setup.py(这里创建app装配环境变量，路由等等，将app返回)| || |+——database| | || | |+——init_data(存放数据库初始化需要信息)| | || | |——*.db/.sqlite3(数据库文件)| | || | |——dbModel.py(数据库模型)| || |+——log（日志）| | | |+——models(视图模型的静态文件以及模板)| | || | |+——admin(后台管理视图)| | | || | | |——static| | | || | | |——templates| | | || | | |——images| | | || | | |——fonts| | | | | |+——login(登录) | | | || | | |+——static| | | || | | |+——templates| | | || | | |+——images| | | || | | |+——fonts| | || | |+——pc_user(Pc用户)| | | || | | |+——static| | | || | | |+——templates| | | || | | |+——images| | | || | | |+——fonts| | | | | |+——public（公用静态或模板）| || |——tools(编写的公用工具)| | || | |+——redis（redis数据库）| | || | |——initdb.py(初始化数据库数据)| || |+——views(视图)| | || | |——admin.py| | || | |——login.py| | || | |——mc_user.py(手机用户)| | || | |——pc_user.py（Pc用户）| || |——config.py（Flask配置文件）||+——install（存放安装辅助脚本，方便用户安装系统）||+——venv（圩您环境）||——.env（敏感环境变量）||——.flaskenv(普通flask环境变量)||——ReadMe.md(项目自述文件)||——run.py（项目启动脚本） 下面是具体文件配置根目录我用root代替，上面图示的app文件夹根据我实际情况开发博客我用的是blogApp 1234567891011# root/application/app.py# 这里真正创建app对象，其他文件从这里调用appfrom blogApp.application.setup import create_appfrom flask import redirect, url_forapp = create_app()@app.route(&quot;/index&quot;)def root(): return redirect(&quot;/pc&quot;) 12345678# root/application/extensions.py# 存放扩展from flask_sqlalchemy import SQLAlchemy# define global extensions in a separate file so that they can be imported from# anywhere else in the code without creating circular imports# the proper initialization is made within the `create_app` functiondb = SQLAlchemy() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# root/application/setup.py# 这里创建app装配环境变量，路由等等，将app返回import osfrom flask import Flaskfrom flask_cors import CORSfrom blogApp.application.extensions import dbimport blogAppfrom blogApp import configdef create_app(): app: Flask = Flask(import_name=blogApp.__name__) print(&quot;app.rootpath(app根路径):&quot;,app.root_path) app.config.from_object(config.DevConfig) # 导入配置 # 相对路劲太坑了，不玩儿了，上绝对吧 app.static_folder = os.path.join(app.config.get(&quot;ROOT_PATH_OBJECT&quot;), r&quot;blogApp\\models\\public\\static&quot;) app.template_folder = os.path.join(app.config.get(&quot;ROOT_PATH_OBJECT&quot;), r&quot;blogApp\\models\\public\\templates&quot;) app.secret_key = os.getenv(&#x27;SECRET_KEY&#x27;) # 导入秘钥 CORS(app, resources=&#123;r&quot;/*&quot;: &#123;&quot;origins&quot;: &quot;*&quot;&#125;&#125;&#123;% endraw %&#125;) # Initialize extensions # 初始化数据库 db.init_app(app) with app.app_context(): # 自动初始化数据库 from blogApp.tools.initdb import initdb initdb() # 添加jinji2全局方法 from blogApp.application.template_global import strlen app.add_template_global(strlen, &#x27;strlen&#x27;) # Register Blueprints # 注册蓝图 from blogApp.views.pc_user import pc_user_view from blogApp.views.admin import admin_view from blogApp.api.pc_user_api import pc_user_api from blogApp.views.login import login_view app.register_blueprint(pc_user_view) app.register_blueprint(login_view) app.register_blueprint(admin_view) app.register_blueprint(pc_user_api) return app 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# root/blogApp/database/dbModel.py# 数据库模型from blogApp.application.extensions import dbclass Article(db.Model): &#x27;&#x27;&#x27; 文章 &#x27;&#x27;&#x27; id = db.Column(db.Integer, primary_key=True) author = db.Column(db.String(80),nullable=False) # 作者 copyright = db.Column(db.Integer,nullable=False) # 版权 title = db.Column(db.String(120),nullable=False) # 标题 outline = db.Column(db.String(255),nullable=False) # 概要 content = db.Column(db.Text) # 内容 creatDate = db.Column(db.Date,nullable=False) # 创建日期 updateDate = db.Column(db.Date,nullable=False) # 更新日期 album = db.Column(db.Text) # 专辑 source = db.Column(db.String(5),nullable=False) # 来源 sort = db.Column(db.Integer,nullable=False) # 分类 tag = db.Column(db.Text) # 标签 cover = db.Column(db.Integer,nullable=False) # 封面图 state = db.Column(db.Integer, nullable=False) # 状态 readnum = db.Column(db.Integer, nullable=True) # 阅读量class Drafts(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(120), nullable=False) # 标题 content = db.Column(db.Text) # 内容 creatDate = db.Column(db.Date, nullable=False) # 创建日期 updateDate = db.Column(db.Date, nullable=False) # 更新日期class Tag_index(db.Model): &#x27;&#x27;&#x27; 标签索引 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(80),nullable=False) # 名称class Sort_index(db.Model): &#x27;&#x27;&#x27; 分类索引 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(80),nullable=False) # 名称class Album_index(db.Model): &#x27;&#x27;&#x27; 专辑索引 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(80),nullable=False) # 名称 outline = db.Column(db.String(255), nullable=False) # 概要class Copyright_index(db.Model): &#x27;&#x27;&#x27; 版权索引 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(80),nullable=False) # 名称 link = db.Column(db.String(255), nullable=False) # 链接class Pic(db.Model): &#x27;&#x27;&#x27; 图片 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(255), nullable=False) # name data = db.Column(db.LargeBinary,nullable=False) # 封面图 type = db.Column(db.Text,nullable=False) # 类型,jpg/png sort = db.Column(db.Integer,nullable=False) # 文章还是其他(0/1) alt = db.Column(db.Text,nullable=False) # 提示信息class User(db.Model): &#x27;&#x27;&#x27; 用户表 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(80),nullable=False) # 昵称 account = db.Column(db.String(120),nullable=False) # 账号 password = db.Column(db.String(120),nullable=False) # 密码 email = db.Column(db.String(120)) # 邮箱 head_portrait = db.Column(db.Integer,nullable=False) # 头像图片idclass Token(db.Model): &#x27;&#x27;&#x27; cookie token表 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id accountId = db.Column(db.Integer) # 对应账户id token = db.Column(db.String(64),nullable=False) # token creatTime = db.Column(db.DateTime,nullable=False) # 创建时间class Friends_link(db.Model): &#x27;&#x27;&#x27; 友链表 &#x27;&#x27;&#x27; id = db.Column(db.Integer,primary_key=True) # id name = db.Column(db.String(256),nullable=False) # 标题 url = db.Column(db.String(256),nullable=False) # 链接 img = db.Column(db.String(256), nullable=False) # 头像图片地址 describe = db.Column(db.Text, nullable=False) # 描述 email = db.Column(db.Text, nullable=False) # 描述 state = db.Column(db.Integer, nullable=False) # 状态 0 正常 1 失效 2 申请添加 3 优质友链 message = db.Column(db.Text, nullable=False) # 留言 response_time = db.Column(db.Integer,nullable=False) # 响应时间 applyDateTime = db.Column(db.DateTime,nullable=False) # 申请时间 addDataTime = db.Column(db.DateTime,nullable=False) # 添加时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189# root/blogApp/tools/initdb.py&#x27;&#x27;&#x27;用于初始化database&#x27;&#x27;&#x27;import datetime&#x27;&#x27;&#x27;顺序不能改先导入db，之后导入app这个过程创建了app并初始化db，最后调用dbModel（他需要等app，db都创建好了才能用）&#x27;&#x27;&#x27;from blogApp.application.extensions import dbfrom blogApp.database import dbModelimport click#@app.cli.command()def initdb(): &#x27;&#x27;&#x27;初始化数据库&#x27;&#x27;&#x27; db.create_all() # 默认添加三个分类项目 if dbModel.Sort_index.query.all() == []: sort1 = dbModel.Sort_index(name=&quot;技术&quot;) sort2 = dbModel.Sort_index(name=&quot;折腾&quot;) sort3 = dbModel.Sort_index(name=&quot;文章&quot;) sort4 = dbModel.Sort_index(name=&quot;生活&quot;) db.session.add(sort1) db.session.add(sort2) db.session.add(sort3) db.session.add(sort4) # 默认添加几个标签 if dbModel.Tag_index.query.all() == []: tag1 = dbModel.Tag_index(name=&quot;Python基础&quot;) tag2 = dbModel.Tag_index(name=&quot;前端&quot;) tag3 = dbModel.Tag_index(name=&quot;后端&quot;) tag4 = dbModel.Tag_index(name=&quot;恋爱&quot;) db.session.add(tag1) db.session.add(tag2) db.session.add(tag3) db.session.add(tag4) # 默认添加几个文章版权信息 if dbModel.Copyright_index.query.all() == []: copyright1 = dbModel.Copyright_index(name=&quot;BSD（Berkeley Software Distribution license）&quot;, link=&quot;https://upimg.baike.so.com/doc/352283-373141.html&quot;) copyright2 = dbModel.Copyright_index(name=&quot;MIT（Massachusetts Institute of Technology）&quot;, link=&quot;https://opensource.org/licenses/MIT&quot;) copyright3 = dbModel.Copyright_index(name=&quot;Apache Licence 2.0&quot;, link=&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;) copyright4 = dbModel.Copyright_index(name=&quot;GPL（General Public License）&quot;, link=&quot;https://getrebuild.com/legal/license&quot;) copyright5 = dbModel.Copyright_index(name=&quot;LGPL（Lesser General Public License）&quot;, link=&quot;https://opensource.org/licenses/lgpl-license&quot;) copyright6 = dbModel.Copyright_index(name=&quot;Mozilla（Mozilla Public License）&quot;, link=&quot;https://www.mozilla.org/en-US/MPL/2.0/&quot;) db.session.add(copyright1) db.session.add(copyright2) db.session.add(copyright3) db.session.add(copyright4) db.session.add(copyright5) db.session.add(copyright6) # 默认为Pic添加几张图片 if dbModel.Pic.query.all() == []: # 默认封图 with open(&quot;blogApp/database/init_data/cover.jpeg&quot;, &quot;rb&quot;) as p: data = p.read() pic1 = dbModel.Pic(name=&quot;文章默认封面图&quot;,data=data, type=&quot;jpg&quot;, sort=0, alt=&quot;我为我代言&quot;) db.session.add(pic1) # 默认头像 with open(&quot;blogApp/database/init_data/head_portrait.jpg&quot;,&quot;rb&quot;)as p: data = p.read() pic2 = dbModel.Pic(name=&quot;默认博主头像&quot;,data=data, type=&quot;jpg&quot;,sort=1,alt=&quot;头像&quot;) db.session.add(pic2) # 添加管理账户 if dbModel.User.query.all() == []: user = dbModel.User(name=&quot;I Speak for myself&quot;, account=&quot;2061360308&quot;, password=&quot;123456&quot;, email=None, head_portrait=1) db.session.add(user) db.session.commit() click.echo(&#x27;Initiali zed database.(数据库初始化完毕)&#x27;) # 添加测试文章数据 if dbModel.Article.query.all() == []: author = &quot;卢澳&quot; Article1 = dbModel.Article(author=author, copyright = 0, title=&quot;测试文章一&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) Article2 = dbModel.Article(author=author, copyright=0, title=&quot;测试文章二&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) Article3 = dbModel.Article(author=author, copyright=0, title=&quot;测试文章三&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) Article4 = dbModel.Article(author=author, copyright=0, title=&quot;测试文章四&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) Article5 = dbModel.Article(author=author, copyright=0, title=&quot;测试文章五&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) Article6 = dbModel.Article(author=author, copyright=0, title=&quot;测试文章六&quot;, outline=&quot;这是测试文章&quot;, content=&quot;&quot;, creatDate=datetime.datetime.now(), updateDate=datetime.datetime.now(), album=None, source=&quot;原创&quot;, sort=1, tag=None, cover=1, state=0, readnum=0, ) db.session.add(Article1) db.session.add(Article2) db.session.add(Article3) db.session.add(Article4) db.session.add(Article5) db.session.add(Article6) db.session.commit() # 添加测试友链申请 if dbModel.Friends_link.query.all() == []: apply1 = dbModel.Friends_link(name=&quot;XX小站&quot;, url=&quot;https://baidu.com&quot;, img=&quot;img.com&quot;, describe=&quot;测试小站&quot;, email=&quot;2061360308@qq.com&quot;, state=2, message=&quot;加下友链&quot;, response_time=5, applyDateTime=datetime.datetime.now(), addDataTime=datetime.datetime.now(), ) db.session.add(apply1) db.session.commit() click.echo(&quot;测试数据载入完毕！&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142# root/blogApp/views/admin.py# 后端视图# 这里只给一个后端蓝图创建的例子，具体根据实际情况import base64import datetimeimport uuidfrom flask import Blueprint, render_template, abort, url_for, \\ current_app, jsonify, request, redirect, sessionfrom blogApp.database import dbModelfrom blogApp.tools.IndexData import indexDatafrom blogApp.tools.check_power import checkLoginStatefrom blogApp.application.extensions import dbfrom blogApp.tools.check_power import checkLoginStateadmin_view = Blueprint(name=&#x27;admin_view&#x27;, import_name=__name__, static_folder=&quot;../models/admin/static&quot;, static_url_path=&quot;/admin_static&quot;, template_folder=&#x27;../models/admin/templates&#x27;, url_prefix=&quot;/admin&quot;, )# 根目录@admin_view.route(&#x27;/&#x27;)def root(): # put application&#x27;s code here data = dbModel.User.query.filter_by(id=1).first() name = data.name head_portrait_id = data.head_portrait head_portrait = dbModel.Pic.query.filter_by(id=head_portrait_id).first().data head_portrait = base64.b64encode(head_portrait).decode(&quot;utf-8&quot;) rootPath = current_app.config.get(&#x27;ROOT_PATH&#x27;) data_templates = render_template(&quot;admin_data.html&quot;, rootPath=rootPath, left_page_name_List=left_page_name_List) return render_template(&quot;admin_base.html&quot;, head_portrait=head_portrait, name=name, rootPath=rootPath, data_templates=data_templates, ) 123# root/blogApp/__init__.py# 包文件，导出appfrom blogApp.application import app 12345678910111213141516171819202122232425262728293031# root/blogApp/config.py# 配置文件，这个其实可以放在很多中格式的文件里的，我这里给出一个py的例子class BaseConfig(object): &#x27;&#x27;&#x27; 公用配置 &#x27;&#x27;&#x27; ROOT_PATH_OBJECT = r&quot;E:\\speakForMyself&quot; # 项目根目录 ROOT_PATH = &quot;http://127.0.0.1:5000/&quot; # 网络环境根目录 SESSION_TYPE = &#x27;filesystem&#x27; # session类型为filesystem LOGIN_COOKIE_NAME = &#x27;identity_token&#x27; # 登录后身份session的键值名称 SQLALCHEMY_TRACK_MODIFICATIONS = Falseclass TestConfig(BaseConfig): &#x27;&#x27;&#x27; 测试环境 &#x27;&#x27;&#x27; passclass DevConfig(BaseConfig): &#x27;&#x27;&#x27; 开发环境 &#x27;&#x27;&#x27; SQLALCHEMY_DATABASE_URI = &#x27;sqlite:///E:/speakForMyself/blogApp/database/data.sqlite3&#x27; # 数据库位置class ProConfig(BaseConfig): &#x27;&#x27;&#x27; 正式环境 &#x27;&#x27;&#x27; pass 1234# root/.env#秘钥SECRET_KEY=089de6ba-7874-11ed-8134-e4fd453f23ec 123456789101112# root/.flaskenv# FLASK_ENV 变量代表运行时的环境时开发环境(development)还是生产环境(production)FLASK_DEBUG=1# FLASK_DEBUG 变量代表是否开启调试器开启1关闭0,开发模式下默认开启,不建议手动操作此项目# FLASK_DEBUG=1# FLASK_APP 变量代表执行flask run命令时要运行的应用文件FLASK_APP=run.py# FLASK_RUN_HOST 变量代表运行的host 0.0.0.0代表外部计算机访问/127.0.0.1代表本机访问FLASK_RUN_HOST=0.0.0.0# FLASK_RUN_PORT 变量代表监听的端口默认5000FLASK_RUN_PORT=5000 1234567# root/run.py# 启动文件from blogApp.application.app import appif __name__ == &quot;__main__&quot;: app.run()","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.1think2program.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"22年12月总结","slug":"总结/2022年12月总结","date":"2023-01-02T08:09:25.000Z","updated":"2023-01-23T15:54:02.501Z","comments":true,"path":"2023/01/02/总结/2022年12月总结/","link":"","permalink":"http://blog.1think2program.cn/2023/01/02/%E6%80%BB%E7%BB%93/2022%E5%B9%B412%E6%9C%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"从12月3号放假回家到现在的23年1月2号，整整一个月了，先总结一下这一个月来我干了点什么吧。 Code 乱七八糟感觉什么也没干成，留下一堆烂摊子 项目 学习 博客后端 Flask 博客后端 js 三创 小程序 hexo编辑器 Python PyQt5 因为要给三创赛写一个电商平台，，且决定后端使用Python Flask所以先进行了一波Flask知识恶补，具体是大概读了【《Flask Web开发实战：入门、进阶与原理解析》_李辉】这本书（后面的例子没有细看） 看了几天Flask后心动了，想动手试试，正好有搭建博客的意愿，所以准备写一个博客系统，上手写了大半个月，目前停滞在后端的markdown编辑器文章提交这块 由于自身前端知识不过关，上手写移动端的网页还是太难了，所以三创作品的前端定好使用小程序，上B站看了千峰教育Kerwin老师的视频之后简单写了一下小程序的前端（说实话，感觉面对这种设计界面的情况自己无能为力~） 使用本地hexo+云端：GitHub仓库 然后托管到了vercel,还有评论系统用的waline部署到了Railway，图床使用腾讯云的cos桶，搭建博客后感觉日常图片的维护太费劲打算自己来写一套，然后风风火火写了三天完成了初期目标的一半左右，然后应为PyQt5的类太乱了，加上三创的时间有点紧，只能过些时间重新整理代码后继续努力了，近期博客的图片只能手动上传了","categories":[{"name":"总结","slug":"总结","permalink":"http://blog.1think2program.cn/categories/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"撒花，第一篇博客","slug":"撒花，第一篇博客","date":"2022-12-27T20:17:29.000Z","updated":"2023-01-16T10:06:40.496Z","comments":true,"path":"2022/12/28/撒花，第一篇博客/","link":"","permalink":"http://blog.1think2program.cn/2022/12/28/%E6%92%92%E8%8A%B1%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"先了解一下博主为什么突然要搭建博客吧~","text":"先了解一下博主为什么突然要搭建博客吧~ 博客起源之前一直在CSDN上写东西，坚持有一段时间了。现在新开个人博客，不过CSDN的文章也会同步的之后有机会搞个自动化什么的。下面说说我博客的起源吧~ 博主感觉编程就应该这样：好奇尝试–&gt;大量踩坑–&gt;果断放弃–&gt;不甘再来 ……不定个轮回……然后终于捣鼓出一些什么。 尽管那些可能就是大家所说的超级不规范垃圾代码，但只要它跑起来就足够让我们开心的了~这个时候呢，我就会想写一点什么东西，把自己折腾半天搞懂的那一点点东西记录下来。 一来是计算机涉及东西太多了，这样记录学习的过程可以帮我更好地沉淀知识， 二来，在我一个人捣鼓各种晦涩的东东的时候，好多人的博文总是能帮助我，当我有了一些网上没有记录或者记录很少的踩坑记录后我也想分享出来帮助更多的人。 说了这么多，也只是表达了我对写博文的观点，至于为什么不好好地继续在CSDN继续写而是自己花费精力搭建和维护个人博客呢？毕竟C站它用户多流量多，跟随者曝光度什么的巴拉巴拉。相信用过CSDN的人都知道他是一个很好的获取编程知识的地方，千千万万程序员，别管是技术大牛还是新手小白大家都在那里学习成长也在C站给我们留下了越来越多的宝贵财富。但就我个人经历来说，我总在C站上翻看各种各样的博客，有时候一篇几万字的文章，我扫过开头的几行就解决了自己的燃眉之急，在也就不会继续往下看了！什么你说点赞收藏关注和评论？抱歉，相信同为程序员的你也理解编程真的会上头的，那个时候这种事情是真的懒啊~所以个人认为C站适合学习但交友的话一般，在我看过博主I am I博客上简单的留言板后我发现这是一个很好的交友平台，尽管他流量少（自信点是没有流量）维护更费力，但如果能在这里收获几个宝贵的圈子的话，那么这一切都是值得的！ 所以我来了！！！ 搭建经历 第一回，自己搭建 因为Python最顺手，所以当时选择了flask做后端，前端样式什么的都是从I am I网站上抄的，感觉这个hexo就很漂亮（就我现在用的这个，当然那个时候我还不知道他是hexo的nexmoe主题）前端写完了，还有个后台管理系统，折腾完文章管理那块，包括我自己还抄CSDN的MarkDown在线编辑器搞了一个魔改版的，毕竟用的顺手了，但是搞完那个以后是真的不想搞了，工作量是真的大，而且一开始是准备部署在腾讯云函数上的内网链接MySQL数据库，但是当我代码越写越大的时候，我不得不考虑我真的能负担器它运行在云函数上的费用吗？（泪奔）这个项目我已经封存在github了后期总结一下这个过程的心得体会，以及开源一下那个魔改版CSDN在线MarkDown编辑器算了~ 第二回，寻找开源代码 这之后我开始在github，gitee，站长之家搜寻有关blog的开源系统包括Python，Java，PHP，Node.js等等都试过了，要不就是太难部署，要么就是界面不好搞，在有这些系统都太大了，我拿到以后想自己改一下下都做不到，太难了根本看不懂 第三回，私人服务器上使用hexo 无奈之下我去问I am I她的博客怎么来的，这之后我才知道了一种新的东西，本地渲染静态文件然后部署到托管服务器，没错就是hexo，当然还有很多其他的类似的工具，博主也试了几个，不过感觉hexo就挺好的了，所以我又又又折腾半天终于将他部署到了我的服务器上，主要是利用Git同步到自己服务器哪一步好难搞，等下一定要记笔记记录下来，这之后我有发现了问题，所以说静态页面我还要私人服务器干嘛，给自己找事？ 第四回，腾讯云COS静态网站 这个比较简单，腾讯云那里专门有教程，视频加文章很清楚，而且一键部署的的插件也有了npm直装就好，我专门选择了香港地域的储存桶，因为这样就可以在不备案的情况下绑定自己的域名了！ 到此差不多这个博客就搭建完成了，不过要说的就是后期waline评论系统的搭建也是花费了一些心思，还有到现在唯一不满意的就是COS图床管理这块还是有点费劲，已经写了一个自动化Python小脚本了，写了一点点，不过也不着急，现在文章还少，管理起来也容易，这个图床优化后期再继续搞也没问题！ 尾声博客上发表的第一篇文章就到这了，接下来我要具体整理一下搭建博客的过程，还有之前手写blog的一些心得，再就是jQuery、Node.js、linux、小程序方面学到的新知识了，害，一看为了这个博客我真是没少折腾啊，朋友们下篇博客再见！——2022&#x2F;12&#x2F;28","categories":[],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://blog.1think2program.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"总结","slug":"总结","permalink":"http://blog.1think2program.cn/categories/%E6%80%BB%E7%BB%93/"}],"tags":[]}